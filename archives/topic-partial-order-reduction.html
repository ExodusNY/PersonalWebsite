<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Partial Order Reduction (POR) — Nitish Yadav</title>
  <meta name="description" content="Concise introduction to Partial Order Reduction (POR) for model checking concurrent programs: Mazurkiewicz traces, persistent sets, and sleep sets." />
  <link rel="icon" href="home-button.png" />

  <!-- Match site theme -->
  <style>
    :root{
      --bg:#0b1220; --card:#0f172a; --text:#e5e7eb; --muted:#94a3b8;
      --border:#1f2a44; --accent:#8ab0ff; --accent-weak:#132647;
      --shadow:0 16px 40px rgba(0,0,0,.35);
      --r:16px; --maxw:1100px; --gutter:16px;
      --nut-bg:rgba(138,176,255,.10);
      --nut-border:#2a4478;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f8fafc; --card:#ffffff; --text:#111827; --muted:#6b7280;
        --border:#e5e7eb; --accent:#527bbd; --accent-weak:#e8effc; --shadow:0 12px 28px rgba(0,0,0,.08);
        --nut-bg:#eef3ff; --nut-border:#c9d8ff;
      }
    }
    *{box-sizing:border-box}
    html,body{margin:0;background:var(--bg);color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Noto Sans",sans-serif;line-height:1.55}
    a{color:var(--accent);text-decoration:none}
    a:hover{text-decoration:underline}

    /* Shared container: nav + content */
    .container{
      max-width:var(--maxw);
      margin:0 auto;
      padding-left:max(var(--gutter), env(safe-area-inset-left));
      padding-right:max(var(--gutter), env(safe-area-inset-right));
      padding-top:16px; padding-bottom:16px;
    }

    /* Nav */
    .nav{position:sticky;top:0;z-index:50;background:rgba(15,23,42,.7);backdrop-filter:blur(10px);border-bottom:1px solid var(--border)}
    @media (prefers-color-scheme: light){ .nav{background:rgba(255,255,255,.75)} }
    .nav-inner{display:flex;align-items:center;justify-content:space-between;gap:12px;padding:10px 0}
    .name{font-weight:800;font-size:20px}

    /* Card */
    .card{background:var(--card);border:1px solid var(--border);border-radius:var(--r);box-shadow:var(--shadow);padding:18px}
    h1{margin:6px 0 10px;font-size:28px;line-height:1.2}
    h2{margin:18px 0 8px;font-size:20px}
    h3{margin:16px 0 8px;font-size:18px}
    .meta{color:var(--muted);font-size:14px;margin-top:-6px}
    .keywords{color:var(--muted);font-size:14px;margin-top:14px}

    /* "In a nut-shell" sub-container */
    .nutshell{
      background:var(--nut-bg);
      border:1px solid var(--nut-border);
      border-radius:12px;
      padding:14px 14px;
      margin-top:10px;
    }
    .nutshell h2{
      margin:0 0 6px 0;
      font-size:18px;
    }

    /* Code-ish blocks */
    pre{
      background:rgba(255,255,255,.04);
      border:1px solid var(--border);
      border-radius:10px;
      padding:12px;
      overflow:auto;
      -webkit-overflow-scrolling:touch;
    }
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace}
    blockquote{
      margin:14px 0; padding:12px 14px; border-left:4px solid var(--accent-weak);
      background:rgba(255,255,255,.03); border-radius:10px;
    }
  </style>

  <!-- Structured data for SEO -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"BlogPosting",
    "headline":"Partial Order Reduction (POR)",
    "description":"Concise introduction to Partial Order Reduction for model checking concurrent programs: Mazurkiewicz traces, persistent sets, and sleep sets.",
    "author":{"@type":"Person","name":"Nitish Yadav"},
    "publisher":{"@type":"Person","name":"Nitish Yadav"},
    "datePublished":"2025-09-01",
    "dateModified":"2025-09-01",
    "keywords":[
      "Partial Order Reduction",
      "POR",
      "Concurrent Programs",
      "Model Checking",
      "Mazurkiewicz Traces",
      "Persistent Sets",
      "Sleep Sets",
      "Stateless Model Checking"
    ],
    "mainEntityOfPage":{"@type":"WebPage","@id":"topic-partial-order-reduction.html"}
  }
  </script>
</head>
<body>
  <!-- NAV -->
  <header class="nav" role="banner">
    <div class="container nav-inner">
      <div class="name"><a href="index.html" style="color:inherit;text-decoration:none"><strong>Nitish Yadav</strong></a></div>
      <nav><a href="blog.html">← Back to Topics</a></nav>
    </div>
  </header>

  <!-- CONTENT -->
  <main class="container" role="main">
    <article class="card">
      <h1>Partial Order Reduction for Verification of Concurrent Systems</h1>
      <p class="meta">Reading time ~4 min · Last updated Sep 2025</p>

      <!-- Sub-container: In a nut-shell -->
      <section class="nutshell" aria-label="Summary">
        <h2>In a nut-shell</h2>
        <p><!-- Write your 2–4 sentence summary here. -->
          Partial Order Reduction (POR) reduces the number of thread interleavings a verifier must explore by pruning schedules that are equivalent up to commuting independent steps. This preserves all behaviors that matter—including bugs—while making systematic exploration tractable.
        </p>
      </section>

      <!-- Main content sections -->

      <h2> Concurrency is non-deterministic</h2>
      <p style="text-align:justify">
        Concurrent programs are <strong>schedule-dependent</strong>: the OS/runtime can interleave thread steps in many valid ways, and different interleavings can lead to different outcomes. A program that “works” once can fail under another schedule; testing a handful of runs isn’t enough.
      </p>

      <p style="text-align: justify">
        Comnsider a concurrent program with two processes A and B. Process A executes two steps and Process B executes two steps. At the end of the execution sequence consider an assert statement (this assert is not part of the program) that evaluates to true only if the value of x and y is 0.
      </p>


      <h3>2) The toy program on the slide</h3>
      <p>Two processes share variables <code>x</code> and <code>y</code>:</p>
      <pre><code>Process A: a1: x := 0;   a2: x := x + 1;   a3: y := x
Process B: b1: x := 0;   b2: x := x + 1;   b3: y := x
assert(y == 2)</code></pre>
      <p>
        <strong>When does <code>y == 2</code> actually hold?</strong> Precisely when (i) both initializations <code>a1</code> and <code>b1</code> happen <em>before</em> both increments <code>a2</code> and <code>b2</code>, and (ii) the last of {<code>a3</code>, <code>b3</code>} executes <em>after</em> both increments. If an initialization (say <code>b1</code>) occurs after an increment (<code>a2</code>), it can erase progress; the final <code>y</code> may be 0 or 1.
      </p>

      <h3>3) Two representative schedules from the slide</h3>
      <ul>
        <li>
          <strong>Lockstep interleaving — Pass</strong><br />
          <code>a1, b1, a2, b2, a3, b3</code><br />
          Both resets first, then both increments, then copies. Final state: <code>x=2, y=2</code> → assertion <strong>passes</strong>.
        </li>
        <li style="margin-top:10px">
          <strong>Sequential interleaving — Fail</strong><br />
          <code>a1, a2, a3, b1, b2, b3</code><br />
          A finishes; B resets <code>x</code> to 0 and only increments once. Final state: <code>x=1, y=1</code> → assertion <strong>fails</strong> (classic lost-update/race).
        </li>
      </ul>
      <p>
        These are just two out of many. Preserving each thread’s order, there are <code>C(6,3) = 20</code> valid interleavings; some pass, some fail.
      </p>

      <h3>4) Why model checking is needed (and why it’s hard)</h3>
      <p>
        <strong>Model checking</strong> systematically explores all reachable schedules to see if any violates the assertion. The challenge is <strong>state-space explosion</strong>: the number of interleavings grows combinatorially with steps and threads.
      </p>

      <h3>5) Partial Order Reduction (POR): pruning redundant schedules</h3>
      <p>
        <strong>POR</strong> avoids schedules that are equivalent up to swapping <em>independent</em> steps—those that commute and do not affect each other’s reads/writes. By exploring one representative from each equivalence class (Mazurkiewicz traces), POR preserves all behaviors that matter while dramatically reducing work. In the toy example many steps touch the same variables, so the reduction is modest; in real systems, POR can collapse vast families of redundant interleavings.
      </p>

      <h3>6) Takeaways for readers</h3>
      <ul>
        <li>Concurrency bugs are <strong>schedule-dependent</strong>; individual tests don’t guarantee safety.</li>
        <li><strong>Systematic exploration</strong> is essential, but naïve enumeration is infeasible.</li>
        <li><strong>POR</strong> is a principled way to make verification tractable without missing real bugs.</li>
      </ul>

      <blockquote>
        <strong>TL;DR:</strong> The two traces (one pass, one fail) are not edge cases—they’re typical of concurrent code. Model checking finds the bad ones; POR makes that search scalable.
      </blockquote>

      <p class="keywords"><strong>keywords:</strong> Partial Order Reduction, POR, Concurrent Programs, Model Checking, Mazurkiewicz Traces, Persistent Sets, Sleep Sets, Stateless Model Checking</p>
    </article>

    <footer style="margin:24px 0;color:#94a3b8;font-size:14px">
      © <span id="yr"></span> Nitish Yadav
    </footer>
  </main>

  <script>
    document.getElementById('yr').textContent = new Date().getFullYear();
  </script>
</body>
</html>
